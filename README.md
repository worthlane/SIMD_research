# Лабораторная работа по изучению SIMD функций

## Цель

В данной работе мы постараемся ускорить алгоритм рисования множества Мандельброта с помощью ```intrinsic``` функций, в том числе мы изучим влияние разных методов оптимизаций на скорость работы трудоёмких для вычисления алгоритмов.

## Рассматриваемый алгоритм

Как пример трудозатратного для вычисления алгоритма рассмотрим [множество Мандельброта](https://ru.wikipedia.org/wiki/Множество_Мандельброта). Вкратце, визуализация данного множества задаётся следующим образом:

1. Зададим радиус некоторой окружности, внутри которой будем строить множество.
2. Теперь выберем некую точку с координатами $(x_0, y_0)$ внутри этой окружности.
3. В зависимости от координат выбранной точки, будем рассматривать следующие точки с координатами $(x_n, y_n)$, где $x_n = x_{n - 1}^2 + y_{n - 1}^2 + x_0$; $y_n = 2 \cdot x \cdot y + y_0$.
4. Будем рассматривать такие точки до тех пор, пока $n$-ная точка не удалится на расстояние, большее чем $R_{MAX}$ (выбранное в первом пункте) от центра окружности.
5. Закрасим самую первую точку с координатами $(x_0, y_0)$ некоторым цветом, зависящим от $n$.

Таким образом мы сможем сгенерировать множество Мандельброта и вывести его визуализацию на экран:

![](pictures/set.jpg)

## Описание действий

Будем сравнивать три примера реализации данного алгоритма.  

1) Простейшая версия без каких либо оптимизаций. Перебор каждой точки по очереди и последовательный рассчет её цвета.
2) Ускоренная массивами версия. Будем последовательно брать массивы нескольких точек подряд, затем так же последовательно рассчитывать цвет каждой точки внутри массива. Таким образом постараемся намекнуть компилятору на возможность упрощения алгоритма.
3) Быстрая версия с использованием AVX инструкций.

Для получения какого-либо результата нам придется сравнивать времена работы для трёх программ. Достаточно точным способом будет использование ассемблерной команды ```rdtsc```, которая возвращает в регистрах ```EDX:EAX``` такт процессора. Напишем функцию на ассемблере, которая будет возвращать такт процессора. Будем считать разницу тактов между началом вычислений Мандельброта и его концом. Таким образом получим время работы алгоритма в своеобразной единице измерения (тактах). Сравнивая эти такты мы сможем делать выводы о различии скоростей при разных оптимизациях.  

Для более точных измерений будем в одной программе замерять время работы для 300 кадров, затем получать среднее количество тактов на один кадр. Будем делать запуск программы 3 раза для того, чтобы получить максимально точный результат (через МНК). После всех этих действий имеет смысл запустить программу вновь, получить контрольный результат и сравнить его с посчитанным ранее средним, сделав вывод об адекватности полученных значений.

## Реализация

### Простейшая версия

Напишем реализацию с последовательным рассчетом цвета для каждой точки и сделаем измерения скорости рисования одного кадра:  

| Оптимизация компилятора | $t_{1}$  | $t_{2}$  | $t_{3}$  | $t_{avg}$ | $t_{control} |
|:-----------------------:|:--------:|:--------:|:--------:|:---------:|:------------:|
|  -O3                    | 50382199 | 50533575 | 50390267 | 50435347  |  50683631    |
|  -O0                    | 98117403 | 97898647 | 98284039 | 98100029  |  98130876    |

Получили, что оптимизация компилятора ускоряет работу программы примерно в $\frac{98100029}{50435347} \approx 1.94$ раза. Результат в целом не удивителен, компилятор действительно круто оптимизирует.





